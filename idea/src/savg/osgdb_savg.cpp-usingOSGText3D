/*
 * SAVG fileloader
 * John Kelso, NIST 10/2009
 *
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

#include <iostream>
#include <string>
#include <sstream>
#include <vector>
#include <osg/Notify>
#include <osg/Node>
#include <osg/Geode>
#include <osg/Group>
#include <osg/Point>
#include <osg/LineWidth>
#include <osg/Material>

#include <osgDB/FileNameUtils>
#include <osgDB/FileUtils>
#include <osgDB/Registry>
#include <osgDB/Export>
#include <osgDB/WriteFile>
#include <osgDB/ReadFile>

#include <osgText/Text3D>

#include <osgUtil/Optimizer>
#include <osgUtil/TriStripVisitor>

#include <dosg.h>

#include <hevUtils.h>
#include <hevOSGUtils.h>
#include <hevDGLUtils.h>

// to convert draw arrays to draw elements
#include "OptVisitor.cpp"

// needed for "loaderBoilerplate.cpp"
#define OSGLOADERFILETYPE savg
#define OSGLOADERSTRING "savg"
#include "loaderBoilerplate.cpp"

// sloppy global variables

// true if trying to be OpenGL3 compatible
bool gl3 ;

// true if we do spewage printfs
static bool spewage ;

// we create a small scenegraph.  Before returning it we trim off unneeded group nodes

// what is returned if using both geometry and text
static osg::Group *group ;

// geometry under this node
static osg::Group *geometryGroup ;

// the opaque geometry is under this group
static osg::Group *opaqueGeometryGroup ;

// opaque points and lines under this geode
static osg::Geode *opaqueGeometryPointsLinesGeode ;
// opaque polys under this geode
static osg::Geode *opaqueGeometryPolysGeode ;

// the transparent geometry is under this group
static osg::Group *transparentGeometryGroup ;

// transparent points and lines under this geode
static osg::Geode *transparentGeometryPointsLinesGeode ;
// transparent polys under this geode
static osg::Geode *transparentGeometryPolysGeode ;

// text under this group
static osg::Group *textGroup ;

// the opaque text is under this group
static osg::Group *opaqueTextGroup ;

// the transparent text is under this group
static osg::Group *transparentTextGroup ;

// used for error messages
static int lineCount = 0 ;
// how big does alpha get before we call it opaque?
static const float opacity  = .9f;
// true if color data includes transparency
static bool transparency = false ;
// vector of vertices
static osg::Vec3Array *coords ;
// vector of normals
static osg::Vec3Array *norms ;
// vector of colors
static osg::Vec4Array *colors ;
// type of primitive we're creating
static enum {END, LINE, POLY, POLYN, TRI, POINT} primitive ;
// color overall, or color per vertex
// BIND_PER_PRIMITIVE is slower than either BIND_OVERALL or BIND_PER_VERTEX!
static enum {OVERALL, VERTEX, DEFAULT} color ;
// number of sides in a polygon if parameter is supplied
static unsigned int sides ; 
// the single primitive color value- also default color if none specified
static osg::Vec4 primColor( 1.f, 1.f, 1.f, 1.f) ;
// size of points and lines in pixels
static float pixelSize = 1.f ;
// true if the default optimizations are not applied- use NOOPTIMIZE command
static bool nooptimize = false ;

// search path for shader files
static std::vector<std::string> shaderpath ;

//std::string attributeTypes[] = { "b", "s", "i", "f", "d", "ub", "us" "ui" } ;

struct attribute {
    int size ;
    //std::string type ;
    std::vector<float> *data ;
} ;
static attribute attributes[16] ;

struct program {
    std::string name ;
    osg::Shader::Type type ;
    GLenum inputType ;
    GLenum outputType ;
    GLint maxVertices ;
    std::string attributes[16] ;
} ;
static std::vector<program> programs ;

// function templates
static bool parseLine(std::vector<std::string> vec) ;
static bool parseText(std::vector<std::string> vec) ;
static bool parseData(std::vector<std::string> vec) ;
static bool parsePixelSize(std::vector<std::string> vec) ;
static bool parsePrimitive(std::vector<std::string> vec) ;
static bool parseAttribute(std::vector<std::string> vec) ;
static bool parseProgram(std::vector<std::string> vec) ;
static bool processPrimitive(void) ;
static bool doPolyN(void) ;
static bool doTriOrPolyOrLineOrPoint(void) ;
static void resetState(void) ;
static bool getColor(std::vector<std::string> vec, unsigned int idx, osg::Vec4 *v) ;
static bool getVec4(std::vector<std::string> vec, unsigned int idx, osg::Vec4 *v) ;
static bool getVec3(std::vector<std::string> vec, unsigned int idx, osg::Vec3 *v) ;
static void ivOutput(std::ofstream &ivfile, std::string ivline) ;
static void polyToTristrip() ;
static void writePrograms(osg::Node *n) ;
static void setTransparency(osg::StateSet *ss) ;
static void printNode(unsigned int, osg::Node*) ;

///////////////////////////////////////////////////////////////////////////
// return a pointer to a node if all's well, or return NULL ;
static osgDB::ReaderWriter::ReadResult parseStream(std::istream& fin) {

    if (getenv("SAVG_VERBOSE")) spewage = true ;
    else spewage = false ;

    if (getenv("SAVG_OPENGL3"))
    {
	gl3 = true ;
    }
    else gl3 = false ;

    // for now just use OpenGL3
    gl3 = true ;
    if (spewage && gl3) fprintf(stderr,"savg loader: using OpenGL3 compatibility\n") ;

    if (spewage) fprintf(stderr, "using the OpenGL3 savg loader\n") ;
    std::string line; 

    // set the search path for shader files
    std::string path ;
    path = ".:" DGL_DATA_DIR ;
    char *osgfilepath = getenv("OSG_FILE_PATH") ;
    if (osgfilepath)
    {
	path += ":" ;
	path += osgfilepath ;
    }

    std::string::size_type idx ;
    while ((idx = path.find(":")) != std::string::npos)
    {
	std::string dir = path.substr(0,idx) ;
	if (dir != "") 
	{
	    shaderpath.push_back(dir) ;
	}
	path = path.substr(idx+1) ;
    }
    if (path != "")
    {
	shaderpath.push_back(path) ;
    }
    
    coords = new osg::Vec3Array ;
    norms = new osg::Vec3Array ;
    colors = new osg::Vec4Array ;

    group = new osg::Group;
    geometryGroup = new osg::Group ;
    opaqueGeometryGroup = new osg::Group ;
    opaqueGeometryPointsLinesGeode = new osg::Geode ;
    opaqueGeometryPolysGeode = new osg::Geode ;
    transparentGeometryGroup = new osg::Group ;
    transparentGeometryPointsLinesGeode = new osg::Geode ;
    transparentGeometryPolysGeode = new osg::Geode ;
    textGroup = new osg::Group ;
    opaqueTextGroup = new osg::Group ;
    transparentTextGroup = new osg::Group ;


#if 1
    group->setName("savg loader: group") ;
    geometryGroup->setName("savg loader: geometryGgroup") ;
    opaqueGeometryGroup->setName("savg loader: opaqueGeometryGroup") ;
    opaqueGeometryPointsLinesGeode->setName("savg loader: opaquePointsLinesGeode") ;
    opaqueGeometryPolysGeode->setName("savg loader: opaquePolysGeode") ;
    transparentGeometryGroup->setName("savg loader: transparentGeometryGroup") ;
    transparentGeometryPointsLinesGeode->setName("savg loader: transparentPointsLinesGeode") ;
    transparentGeometryPolysGeode->setName("savg loader: transparentPolysGeode") ;
    textGroup->setName("savg loader: textGgroup") ;
    opaqueTextGroup->setName("savg loader: opaqueTextGroup") ;
    transparentTextGroup->setName("savg loader: transparentTextGroup") ;
#endif

    group->addChild(geometryGroup) ;
    group->addChild(textGroup) ;

    geometryGroup->addChild(opaqueGeometryGroup) ;
    geometryGroup->addChild(transparentGeometryGroup) ;
    
    textGroup->addChild(opaqueTextGroup) ;
    textGroup->addChild(transparentTextGroup) ;
    
    opaqueGeometryGroup->addChild(opaqueGeometryPointsLinesGeode) ;
    opaqueGeometryGroup->addChild(opaqueGeometryPolysGeode) ;

    transparentGeometryGroup->addChild(transparentGeometryPointsLinesGeode) ;
    transparentGeometryGroup->addChild(transparentGeometryPolysGeode) ;

    opaqueGeometryPointsLinesGeode->getOrCreateStateSet()->setMode(GL_LIGHTING, osg::StateAttribute::OFF | osg::StateAttribute::PROTECTED) ;
    transparentGeometryPointsLinesGeode->getOrCreateStateSet()->setMode(GL_LIGHTING, osg::StateAttribute::OFF | osg::StateAttribute::PROTECTED) ;
    
    memset(attributes, 0, sizeof(attributes)) ;

    while (getline(fin, line)) 
    {
	lineCount++ ;
	if (osg::isNotifyEnabled(osg::INFO) && !(lineCount%1000))
	{
	    osg::notify( osg::INFO ) << OSGLOADERSTRING << ": " << lineCount << " lines read\n" ;
	}


	// chop off trailing spaces
	line = line.substr(0,line.find_last_not_of(" ")+1) ;

	osg::notify( osg::DEBUG_INFO ) << lineCount << ": line = " << line << std::endl ;
	std::vector<std::string> vec = hevUtils::parseString(line) ;

	if (vec.size() >0)
	{
	    if (!parseLine(vec)) 
	    {
		osg::notify( osg::FATAL ) << OSGLOADERSTRING" file loader:: line number " 
					  << lineCount << ", invalid line: " << line << std::endl ;
		return NULL ;
	    }
	}
    }
    
    // do whatever's piled up at the end of data
    std::vector<std::string> vec ;
    parseLine(vec) ;

    if (osg::isNotifyEnabled(osg::INFO))
	osg::notify( osg::INFO ) << OSGLOADERSTRING << ": " << lineCount << " total lines read\n" ;


#if 1
    fprintf(stderr,"group node has %d children\n", group->getNumChildren()) ;
    fprintf(stderr,"geometryGroup node has %d children\n", geometryGroup->getNumChildren()) ;
    fprintf(stderr,"opaqueGeometryGroup node has %d children\n", opaqueGeometryGroup->getNumChildren()) ;
    fprintf(stderr,"opaqueGeometryPointsLinesGeode has %d drawables\n", opaqueGeometryPointsLinesGeode->getNumDrawables()) ;
    fprintf(stderr,"opaqueGeometryPolysGeode has %d drawables\n", opaqueGeometryPolysGeode->getNumDrawables()) ;
    fprintf(stderr,"transparentGeometryGroup node has %d children\n", transparentGeometryGroup->getNumChildren()) ;
    fprintf(stderr,"transparentGeometryPointsLinesGeode has %d drawables\n", transparentGeometryPointsLinesGeode->getNumDrawables()) ;
    fprintf(stderr,"transparentGeometryPolysGeode has %d drawables\n", transparentGeometryPolysGeode->getNumDrawables()) ;
    fprintf(stderr,"textGroup node has %d children\n", textGroup->getNumChildren()) ;
    fprintf(stderr,"opaqueTextGroup node has %d children\n", opaqueTextGroup->getNumChildren()) ;
    fprintf(stderr,"transparentTextGroup node has %d children\n", transparentTextGroup->getNumChildren()) ;
#endif


    // trim the tree, removing nodes with no children
    if (opaqueGeometryPointsLinesGeode->getNumDrawables() == 0) opaqueGeometryGroup->removeChild(opaqueGeometryPointsLinesGeode) ;
    if (opaqueGeometryPolysGeode->getNumDrawables() == 0) opaqueGeometryGroup->removeChild(opaqueGeometryPolysGeode) ;
    if (transparentGeometryPointsLinesGeode->getNumDrawables() == 0) transparentGeometryGroup->removeChild(transparentGeometryPointsLinesGeode) ;
    if (transparentGeometryPolysGeode->getNumDrawables() == 0) transparentGeometryGroup->removeChild(transparentGeometryPolysGeode) ;

    if (opaqueGeometryGroup->getNumChildren() == 0) geometryGroup->removeChild(opaqueGeometryGroup) ;
    if (transparentGeometryGroup->getNumChildren() == 0) geometryGroup->removeChild(transparentGeometryGroup) ;

    if (opaqueTextGroup->getNumChildren() == 0) textGroup->removeChild(opaqueTextGroup) ;
    if (transparentTextGroup->getNumChildren() == 0) textGroup->removeChild(transparentTextGroup) ;

    if (geometryGroup->getNumChildren() == 0) group->removeChild(geometryGroup) ;
    if (textGroup->getNumChildren() == 0) group->removeChild(textGroup) ;


#if 1
    fprintf(stderr,"tree trimmed, here's what's left:\n") ;
    printNode(1,group) ;
#endif

    // what's the minimal scenegraph we need to return?
    osg::Node *node ;

    if (group->getNumChildren() == 0)
    {
	fprintf(stderr,"using NULL\n") ;
	node = NULL ;
    }
    else if (group->getNumChildren() == 2)
    {
	fprintf(stderr,"using group\n") ;
	node = group ;
    }
    else // only one child- which one?
    {
	if (geometryGroup->getNumChildren() > 0)
	{
	    if (geometryGroup->getNumChildren() == 2)
	    {
		fprintf(stderr,"using geometryGroup\n") ;
		node = geometryGroup ;
	    }  
	    else if (geometryGroup->getNumChildren() == 1) // only one child- which one?
	    {
		if (opaqueGeometryGroup->getNumChildren() > 0)
		{
		    if (opaqueGeometryGroup->getNumChildren() == 2)
		    {
			fprintf(stderr,"using opaqueGeometryGroup\n") ;
			node = opaqueGeometryGroup ;
		    }
		    else if (opaqueGeometryGroup->getNumChildren() == 1)
		    {
			if (opaqueGeometryPolysGeode->getNumDrawables() > 0)
			{
			    fprintf(stderr,"using opaqueGeometryPolysGeode\n") ;
			    node = opaqueGeometryPolysGeode ;
			}
			else if (opaqueGeometryPointsLinesGeode->getNumDrawables() > 0) 
			{
			    fprintf(stderr,"using opaqueGeometryPointsLinesGeode\n") ;
			    node = opaqueGeometryPointsLinesGeode ;
			}
			else
			{
			    fprintf(stderr,"%s: logic error at line %d\n") ;
			    exit(1) ;
			}
		    }
		    else
		    {
			fprintf(stderr,"%s: logic error at line %d\n") ;
			exit(1) ;
		    }
		}
		else if (transparentGeometryGroup->getNumChildren() > 0)
		{
		    if (transparentGeometryGroup->getNumChildren() == 2)
		    {
			fprintf(stderr,"using transparentGeometryGroup\n") ;
			node = transparentGeometryGroup ;
		    }
		    else if (transparentGeometryGroup->getNumChildren() == 1)
		    {
			if (transparentGeometryPolysGeode->getNumDrawables() > 0)
			{
			    fprintf(stderr,"using transparentGeometryPolysGeode\n") ;
			    osg::StateSet *stateSet = transparentGeometryPolysGeode->getOrCreateStateSet() ;
			    setTransparency(stateSet) ;
			    node = transparentGeometryPolysGeode ;
			}
			else if (transparentGeometryPointsLinesGeode->getNumDrawables() > 0) 
			{
			    fprintf(stderr,"using transparentGeometryPointsLinesGeode\n") ;
			    osg::StateSet *stateSet = transparentGeometryPointsLinesGeode->getOrCreateStateSet() ;
			    setTransparency(stateSet) ;
			    node = transparentGeometryPointsLinesGeode ;
			}
			else
			{
			    fprintf(stderr,"%s: logic error at line %d\n") ;
			    exit(1) ;
			}
		    }
		    else
		    {
			fprintf(stderr,"%s: logic error at line %d\n") ;
			exit(1) ;
		    }
		}
		else
		{
		    fprintf(stderr,"%s: logic error at line %d\n") ;
		    exit(1) ;
		}
	    }
	    else
	    {
		fprintf(stderr,"%s: logic error at line %d\n") ;
		exit(1) ;
	    }
	}
	else if (textGroup->getNumChildren() > 0)
	{
	    if (textGroup->getNumChildren() == 2)
	    {
		fprintf(stderr,"using textGroup\n") ;
		node = textGroup ;
	    }
	    else if (textGroup->getNumChildren() == 1) // only one child- which one?
	    {
		if (opaqueTextGroup->getNumChildren() > 0)
		{
		    fprintf(stderr,"using opaqueTextGroup\n") ;
		    node = opaqueTextGroup ;
		}
		else if (transparentTextGroup->getNumChildren() > 0)
		{
		    fprintf(stderr,"using transparentTextGroup\n") ;
		    osg::StateSet *stateSet = transparentTextGroup->getOrCreateStateSet() ;
		    setTransparency(stateSet) ;
		    node = transparentTextGroup ;
		}
		else
		{
		    fprintf(stderr,"%s: logic error at line %d\n") ;
		    exit(1) ;
		}
	    }
	    else
	    {
		fprintf(stderr,"%s: logic error at line %d\n") ;
		exit(1) ;
	    }
	}
	else
	{
	    fprintf(stderr,"%s: logic error at line %d\n") ;
	    exit(1) ;
	}
    }

    time_t t1, t2 ;
    // get a list of optimizations to apply one at a time
    std::vector<std::string> optimization ;
    std::string opts ;
    if (getenv("OSG_OPTIMIZER")) 
    {
	opts = getenv("OSG_OPTIMIZER") ;

	std::string::size_type idx ;
	while ((idx = opts.find(":")) != std::string::npos)
	{
	    std::string opt = opts.substr(0,idx) ;
	    if (opt != "") 
	    {
		optimization.push_back(opt) ;
	    }
	    opts = opts.substr(idx+1) ;
	}
	if (opts != "")
	{
	    optimization.push_back(opts) ;
	}
	
	for (unsigned int i=0; i<optimization.size(); i++)
	{
	    setenv("OSG_OPTIMIZER",optimization[i].c_str(),1) ;
	    osgUtil::Optimizer *o = new osgUtil::Optimizer() ;
	    if (spewage) fprintf(stderr,"savg file loader: applying optimization \"%s\"... ",optimization[i].c_str()) ;
	    t1 = time(NULL) ;
	    o->optimize(node) ;
	    t2 = time(NULL) ;
	    if (spewage) fprintf(stderr,"took %d seconds\n",t2-t1) ;
	} 
    }
    else if (!nooptimize)
    {
	if (spewage) fprintf(stderr,"savg file loader: stripifying... ") ;	
	osgUtil::TriStripVisitor *tsv = new osgUtil::TriStripVisitor ;
	t1 = time(NULL) ;
	node->accept(*tsv) ;
	tsv->setCacheSize(16) ;
	tsv->stripify();
	t2 = time(NULL) ;
	if (spewage) fprintf(stderr,"took %d seconds\n",t2-t1) ;
	
	if (spewage) fprintf(stderr,"savg file loader: merging geometry... ") ;	
	osgUtil::Optimizer::MergeGeometryVisitor *mgv = new osgUtil::Optimizer::MergeGeometryVisitor ;
	t1 = time(NULL) ;
	mgv->setTargetMaximumNumberOfVertices(65536);
	node->accept(*mgv) ;
	t2 = time(NULL) ;
	if (spewage) fprintf(stderr,"took %d seconds\n",t2-t1) ;
    }

    //printf("#%s %d\n",__FILE__,__LINE__) ;

    if (gl3)
    {
	// convert to DrawElements
	t1 = time(NULL) ;
	if (spewage) fprintf(stderr,"savg file loader: converting to draw elements... ") ;	
	OptVisitor *ov = new OptVisitor ;
	node->accept(*ov) ;
	t2 = time(NULL) ;
	if (spewage) fprintf(stderr,"took %d seconds\n",t2-t1) ;
    }

    writePrograms(node) ;

    return node ;

}

////////////////////////////////////////////////////////////////////////
static bool parseLine(std::vector<std::string> vec)
{

#if 0
    std::clog << vec.size() << " parameters\n" ;
    for (unsigned int i=0; i< vec.size(); i++)
	std::clog << i << ": " << vec[i] << std::endl ;
#endif

    if (vec.size()==0 || (vec.size() == 1 && hevUtils::isSubstring("end",vec[0],3)))
	return processPrimitive() ;
    else if (parseData(vec)) //parse data first, as other keywords can signal end of data
	return true ;
    else if (parsePrimitive(vec))
	return true ;
    else if (parseText(vec))
	return true ;
    else if (parsePixelSize(vec))
	return true ;
    else if (parseAttribute(vec))
	return true ;
    else if (parseProgram(vec))
	return true ;
    else if (hevUtils::isSubstring("NOOPTIMIZE",vec[0],3))
    {
	nooptimize = true ;
    }
    else if (hevUtils::isSubstring("ALPHA",vec[0],3) ||
	     hevUtils::isSubstring("AMBIENT",vec[0],3) ||
	     hevUtils::isSubstring("COLORMODE",vec[0],3) ||
	     hevUtils::isSubstring("DIFFUSE",vec[0],3) ||
	     hevUtils::isSubstring("EMISSION",vec[0],3) ||
	     hevUtils::isSubstring("INDEXED",vec[0],3) ||
	     hevUtils::isSubstring("LIGHTING",vec[0],3) ||
	     hevUtils::isSubstring("OCTREE",vec[0],3) ||
	     hevUtils::isSubstring("PRESERVEPLANARCHECKING",vec[0],15) ||
	     hevUtils::isSubstring("PRESERVEPLANARQUADS",vec[0],15) ||
	     hevUtils::isSubstring("SHININESS",vec[0],3) ||
	     hevUtils::isSubstring("SHRINKAGE",vec[0],3) ||
	     hevUtils::isSubstring("SPECULAR",vec[0],3) ||
	     hevUtils::isSubstring("STRIPLENGTH",vec[0],3) ||
	     hevUtils::isSubstring("STYLE",vec[0],3) ||
	     hevUtils::isSubstring("TEXTURE",vec[0],5) ||
	     hevUtils::isSubstring("TRANSPARENCY",vec[0],3) ||
	     hevUtils::isSubstring("VERBOSITY",vec[0],3) )
    {
	osg::notify( osg::WARN ) << OSGLOADERSTRING" file loader:: ignoring unimplemented command: " << vec[0] << ", line " << lineCount << "\n" ;
	return true ;
    }
    else
    {
	osg::notify( osg::FATAL ) << OSGLOADERSTRING" file loader:: unknown line syntax or line incompatible with earlier lines\n" ;
	return false ;
    }

    // return false earlier on error
    return true ;
}

////////////////////////////////////////////////////////////////////////
static bool processPrimitive(void)
{
    if (coords->size()>0)
    {
	if (norms->size()>0 && (norms->size() != coords->size()))
	{
	    osg::notify( osg::FATAL ) << OSGLOADERSTRING" file loader:: normals supplied, and number of vertices not equal to number of normals- norms->size()=" << norms->size() << ",coords->size()=" << coords->size() << "\n" ; 
	    return false ;
	}
      
	if (colors->size()>0 && (colors->size() != coords->size()))
	{
	    osg::notify( osg::FATAL ) << OSGLOADERSTRING" file loader:: colors supplied, and number of vertices not equal to number of colors- colors->size()=" << colors->size() << ",coords->size()=" << coords->size() << "\n" ; 
	    return false ;
	}
      
	if (primitive==POLYN)
	{
	    if (!doPolyN())
	    {
		return false ;
	    }
	}
	else if (!doTriOrPolyOrLineOrPoint())
	    return false ;

	resetState() ;
    }
    return true ;
}

////////////////////////////////////////////////////////////////////////
static bool parsePrimitive(std::vector<std::string> vec) 
{
    // process previous primitive, if any
    if (!processPrimitive()) return false ;
    else if (hevUtils::isSubstring("tristrips",vec[0],3))
    {
	primitive = TRI ;
    }
    else if (hevUtils::isSubstring("polygons",vec[0],3))
    {
	primitive = POLY ;
    }
    else if (hevUtils::isSubstring("lines",vec[0],3))
    {
	primitive = LINE ;
    }
    else if (hevUtils::isSubstring("points",vec[0],3))
    {
	primitive = POINT ;
    }
    else return false ;
  
    if (vec.size() == 1) //prim
    {
	color = DEFAULT ;  // might use default or might specify in data
	return true ;
    }
    else if (vec.size() == 5 && getColor(vec, 1, &primColor)) //prim r g b a
    {
	color = OVERALL ;
	if (primColor.a() <= opacity) 
	    transparency = true ;
	return true ;
    }
    else if (primitive == POLY && vec.size() == 2 && hevUtils::putUnsignedInt(vec[1], &sides)) //poly n
    {
	color = DEFAULT ; // might use default or might specify in data
	primitive = POLYN ;
	return true ;
    }
    else if (primitive == POLY && vec.size() == 6 && getColor(vec, 1, &primColor) && 
	     hevUtils::putUnsignedInt(vec[5], &sides)) //poly r g b a n
    {
	primitive = POLYN ;
	color = OVERALL ;
	if (primColor.a() <= opacity) 
	    transparency = true ;
	return true ;
    }
    else
    {
	return false ;
    }
}

////////////////////////////////////////////////////////////////////////
static bool parseData(std::vector<std::string> vec)
{
    static osg::Vec3 v ;
    static osg::Vec3 n ;
    static osg::Vec4 c ;

    // find and remove vertex attribute data
    {
	unsigned int firstAttributeIndex = 0 ;
	// need at least three floats before attribute keyword- keeps us from mistaking this line for an attribute command
	for (unsigned int i=3; i<vec.size(); i++)
	{
	    if (hevUtils::isSubstring("ATTRIBUTE",vec[i],3))
	    {
		if (firstAttributeIndex == 0) 
		{
		    firstAttributeIndex = i ;
		}
		if (vec.size() == i+1) return false ; // no data!
		i++ ;
		int index ;
		if (!hevUtils::putInt(vec[i], &index)) return false ;
		if (attributes[index].size == 0) return false ; // no attribute with this index declared earlier
		int size = attributes[index].size ;
		if (vec.size() < i+size+1) return false ; // not enough data!
		i++ ;
		for (unsigned int j=0; j<size; j++)
		{
		    float d ;
		    if (!hevUtils::putFloat(vec[i+j],&d)) return false ;
		    attributes[index].data->push_back(d) ;
		}
	    }
	}
	// chop off vector starting at firstAttributeIndex
	if (firstAttributeIndex > 0) vec.resize(firstAttributeIndex) ;
    }


    // data without a primitive type
    if (primitive==END)
	return false ;
    else if (vec.size() == 3 && getVec3(vec, 0, &v)) //vertex
    {
	if (color == VERTEX)
	    return false ;
	coords->push_back(v) ;
	return true ;
    }
    else if (vec.size() == 6 && getVec3(vec, 0, &v) && getVec3(vec, 3, &n)) //vertex normal
    {
	if (color == VERTEX)
	    return false ;
	coords->push_back(v) ;
	norms->push_back(n) ;
	return true ;
    }
    else if (vec.size() == 7 && getVec3(vec, 0, &v) && getVec4(vec, 3, &c)) //vertex color
    {
	if (color == OVERALL)
	    return false ;
	if (primColor.a() <= opacity) 
	    transparency = true ;
	coords->push_back(v) ;
	colors->push_back(c) ;
	primColor = c ;
	color = VERTEX ;
	return true ;
    }
    else if (vec.size() == 10 && getVec3(vec, 0, &v) && getVec4(vec, 3, &c) 
	     && getVec3(vec, 7, &n)) //vertex color normal
    {
	if (color == OVERALL)
	    return false ;
	if (primColor.a() <= opacity) 
	    transparency = true ;
	coords->push_back(v) ;
	norms->push_back(n) ;
	colors->push_back(c) ;
	primColor = c ;
	color = VERTEX ;
	return true ;
    }
    else
	return false ;
}

////////////////////////////////////////////////////////////////////////
static bool parsePixelSize(std::vector<std::string> vec)
{
    // process previous primitive, if any
    if (!processPrimitive())
	return false ;
    else if (vec.size()==2 && hevUtils::isSubstring("pixelsize",vec[0],3) && hevUtils::putFloat(vec[1], &pixelSize))
    {
	osg::StateSet *opaqueStateSet = opaqueGeometryPointsLinesGeode->getOrCreateStateSet() ;
	osg::StateSet *transparentStateSet = transparentGeometryPointsLinesGeode->getOrCreateStateSet() ;

	opaqueStateSet->setMode(GL_POINT_SMOOTH, osg::StateAttribute::ON);
	transparentStateSet->setMode(GL_POINT_SMOOTH, osg::StateAttribute::ON);

	osg::Point *point = new osg::Point(pixelSize) ;
	opaqueStateSet->setAttribute(point, osg::StateAttribute::ON);
	transparentStateSet->setAttribute(point, osg::StateAttribute::ON);

	opaqueStateSet->setMode(GL_LINE_SMOOTH, osg::StateAttribute::ON | osg::StateAttribute::PROTECTED) ;
	transparentStateSet->setMode(GL_LINE_SMOOTH, osg::StateAttribute::ON | osg::StateAttribute::PROTECTED) ;

	opaqueStateSet->setMode(GL_VERTEX_PROGRAM_POINT_SIZE, osg::StateAttribute::ON | osg::StateAttribute::PROTECTED) ;
	transparentStateSet->setMode(GL_VERTEX_PROGRAM_POINT_SIZE, osg::StateAttribute::ON | osg::StateAttribute::PROTECTED) ;


	osg::LineWidth *linewidth = new osg::LineWidth;
	linewidth->setWidth(pixelSize);
	opaqueStateSet->setAttribute(linewidth, osg::StateAttribute::ON);
	transparentStateSet->setAttribute(linewidth, osg::StateAttribute::ON);

	return true ;
    }
    else
	return false ;	
}

////////////////////////////////////////////////////////////////////////
static bool parseText(std::vector<std::string> vec)
{
    // process previous primitive, if any
    if (!processPrimitive())
	return false ;
    else if (vec.size()>2 && hevUtils::isSubstring("text",vec[0],3))
    {

	osgText::Text3D *text = new osgText::Text3D;
	osg::Geode* geode  = new osg::Geode;
	bool textTransparency = false ;
	text->setFont("fonts/arial.ttf");
	text->setAlignment(osgText::TextBase::LEFT_BOTTOM) ;
	text->setCharacterSizeMode(osgText::TextBase::OBJECT_COORDS) ;
	text->setCharacterSize(1,1) ;
	text->setCharacterDepth(1) ;
	text->setRotation(osg::Quat(sqrt(2),0,0,sqrt(2))) ;
	//text->setRenderMode(osgText::Text3D::PER_GLYPH) ;
	unsigned int i=1 ;
	while (i<vec.size())
	{
	    if (hevUtils::isSubstring("string",vec[i],3))
	    {
		i++ ;
		if (i<vec.size())
		{
		    text->setText(vec[i]) ;
#if 1
		    geode->setName("savg loader: text: " + vec[i]) ;
#endif
		    i++ ;
		}
		else
		    return false ;
	    }
	    else if (hevUtils::isSubstring("font",vec[i],3))
	    {
		i++ ;
		if (i<vec.size())
		{
		    text->setFont(vec[i]) ;
		    i++ ;
		}
		else
		    return false ;
	    }
	    else if (hevUtils::isSubstring("justification",vec[i],3))
	    {
		i++ ;
		if (i<vec.size())
		{
		    if (hevUtils::isSubstring("left",vec[i])) text->setAlignment(osgText::TextBase::LEFT_BASE_LINE) ;
		    else if (hevUtils::isSubstring("center",vec[i])) text->setAlignment(osgText::TextBase::CENTER_BASE_LINE) ;
		    else if (hevUtils::isSubstring("right",vec[i])) text->setAlignment(osgText::TextBase::RIGHT_BASE_LINE) ;
		    i++ ;
		}
		else
		    return false ;
	    }
	    else if (hevUtils::isSubstring("alignment",vec[i],3))
	    {
		i++ ;
		if (i<vec.size())
		{
		    if (hevUtils::isSubstring("left_top",vec[i])) text->setAlignment(osgText::TextBase::LEFT_TOP) ;
		    else if (hevUtils::isSubstring("left_center",vec[i])) text->setAlignment(osgText::TextBase::LEFT_CENTER) ;
		    else if (hevUtils::isSubstring("left_bottom",vec[i])) text->setAlignment(osgText::TextBase::LEFT_BOTTOM) ;
		    else if (hevUtils::isSubstring("left_base_line",vec[i])) text->setAlignment(osgText::TextBase::LEFT_BASE_LINE) ;
		    else if (hevUtils::isSubstring("left_bottom_base_line",vec[i])) text->setAlignment(osgText::TextBase::LEFT_BOTTOM_BASE_LINE) ;
		    else if (hevUtils::isSubstring("center_top",vec[i])) text->setAlignment(osgText::TextBase::CENTER_TOP) ;
		    else if (hevUtils::isSubstring("center_center",vec[i])) text->setAlignment(osgText::TextBase::CENTER_CENTER) ;
		    else if (hevUtils::isSubstring("center_bottom",vec[i])) text->setAlignment(osgText::TextBase::CENTER_BOTTOM) ;
		    else if (hevUtils::isSubstring("center_base_line",vec[i])) text->setAlignment(osgText::TextBase::CENTER_BASE_LINE) ;
		    else if (hevUtils::isSubstring("center_bottom_base_line",vec[i])) text->setAlignment(osgText::TextBase::CENTER_BOTTOM_BASE_LINE) ;
		    else if (hevUtils::isSubstring("right_top",vec[i])) text->setAlignment(osgText::TextBase::RIGHT_TOP) ;
		    else if (hevUtils::isSubstring("right_center",vec[i])) text->setAlignment(osgText::TextBase::RIGHT_CENTER) ;
		    else if (hevUtils::isSubstring("right_bottom",vec[i])) text->setAlignment(osgText::TextBase::RIGHT_BOTTOM) ;
		    else if (hevUtils::isSubstring("right_base_line",vec[i])) text->setAlignment(osgText::TextBase::RIGHT_BASE_LINE) ;
		    else if (hevUtils::isSubstring("right_bottom_base_line",vec[i])) text->setAlignment(osgText::TextBase::RIGHT_BOTTOM_BASE_LINE) ;
		    i++ ;
		}
		else
		    return false ;
	    }
	    else if (hevUtils::isSubstring("xyz",vec[i],3))
	    {
		i++ ;
		float x, y, z ;
		if (i+2<vec.size() && 
		    hevUtils::putFloat(vec[i], &x) &&
		    hevUtils::putFloat(vec[i+1], &y) &&
		    hevUtils::putFloat(vec[i+2], &z) )
		{
		    text->setPosition(osg::Vec3(x, y, z)) ;
 		    i+=3 ;
		}
		else
		    return false ;
	    }
	    else if (hevUtils::isSubstring("sxyz",vec[i],3))
	    {
		i++ ;
		float x, y, z ;
		if (i+2<vec.size() && 
		    hevUtils::putFloat(vec[i], &x) &&
		    hevUtils::putFloat(vec[i+1], &y) &&
		    hevUtils::putFloat(vec[i+2], &z) )
		{
		    text->setCharacterSize(x,y/x) ;
		    text->setCharacterDepth(z) ;
 		    i+=3 ;
		}
	    }
	    else if (hevUtils::isSubstring("s",vec[i]))
	    {
		i++ ;
		float s ;
		if (i<vec.size() && hevUtils::putFloat(vec[i], &s))
		{
		    text->setCharacterSize(s,s) ;
		    text->setCharacterDepth(s) ;
		    i++ ;
		}
		else
		    return false ;
	    }
	    else if (hevUtils::isSubstring("hpr",vec[i],3))
	    {
		i++ ;
		float h, p, r;
		if (i+2<vec.size() && 
		    hevUtils::putFloat(vec[i], &h) &&
		    hevUtils::putFloat(vec[i+1], &p) &&
		    hevUtils::putFloat(vec[i+2], &r) )
		{
		    text->setRotation(osg::Quat(sqrt(2),0,0,sqrt(2))*DOSGUtil::euler_to_quat(h,p,r)) ;
		    i+=3 ;
		}
		else
		{
		    return false ;
		}
	    }
	    else if (hevUtils::isSubstring("rgba",vec[i],3))
	    {
		i++ ;
		float r, g, b, a ;
		if (i<vec.size() && 
		    hevUtils::putFloat(vec[i], &r) &&
		    hevUtils::putFloat(vec[i+1], &g) &&
		    hevUtils::putFloat(vec[i+2], &b) &&
		    hevUtils::putFloat(vec[i+3], &a) )
		{
		    osg::Material* front = new osg::Material ;
		    front->setAlpha(osg::Material::FRONT_AND_BACK,1) ;
		    //front->setAmbient(osg::Material::FRONT_AND_BACK,osg::Vec4(0.2,0.2,0.2,1.0)) ;
		    //front->setEmission(osg::Material::FRONT_AND_BACK,osg::Vec4(r,g,b,a)) ;
		    front->setDiffuse(osg::Material::FRONT_AND_BACK,osg::Vec4(r,g,b,a)) ;
		    geode->getOrCreateStateSet()->setAttributeAndModes(front) ;
		    i+=4 ;
		    if (a <= opacity) textTransparency = true ;
		    else textTransparency = false ;
		}
		else
		    return false ;
	    }
	    else 
	    {
		return false ;
	    }
	}
	geode->addDrawable(text);
	if (textTransparency) transparentTextGroup->addChild(geode) ;
	else opaqueTextGroup->addChild(geode) ;
	return true ;
    }
    else return false ;
}
////////////////////////////////////////////////////////////////////////
static void resetState(void)
{
    primitive = END ;
    coords->clear() ;
    norms->clear() ;
    color = DEFAULT ;
    colors->clear() ;
    sides = 0 ;
    transparency = false ;
    {
	for (unsigned int i=1; i<16; i++) if (attributes[i].size != 0) attributes[i].data->clear() ;
    }
}

////////////////////////////////////////////////////////////////////////
static bool getColor(std::vector<std::string> t, unsigned int i, osg::Vec4 *v)
{
    return (getVec4(t, i, v) && v->r()>=0.f && 
	    v->r()<=1.0 && v->g()>=0.f && v->g()<=1.0 &&  v->b()>=0.f && 
	    v->b()<=1.0 && v->a()>=0.f && v->a()<=1.0) ;
}

////////////////////////////////////////////////////////////////////////
static bool getVec3(std::vector<std::string> t, unsigned int i, osg::Vec3 *v)
{
    return hevUtils::putFloat(t[i], &(v->x())) && hevUtils::putFloat(t[i+1], &(v->y())) && 
	hevUtils::putFloat(t[i+2], &(v->z())) ;
}

////////////////////////////////////////////////////////////////////////
static bool getVec4(std::vector<std::string> t, unsigned int i, osg::Vec4 *v)
{
    return hevUtils::putFloat(t[i], &(v->x())) && hevUtils::putFloat(t[i+1], &(v->y())) && 
	hevUtils::putFloat(t[i+2], &(v->z())) && hevUtils::putFloat(t[i+3], &(v->w())) ;
}

////////////////////////////////////////////////////////////////////////
// output a line of inventor text with automatic indentation
static void ivOutput(std::ofstream &ivfile, std::string ivline)
{
    static unsigned int ivlevel = 0 ;

    bool obrace = !(ivline.find("{") ==  std::string::npos);
    bool cbrace = !(ivline.find("}") ==  std::string::npos);


    if (cbrace && !obrace)
    {
	ivlevel-- ;
	ivfile << hevUtils::indent(ivline+"\n", ivlevel) ;
    }
    else if (!cbrace && obrace)
    {
	ivfile << hevUtils::indent(ivline+"\n", ivlevel) ;
	ivlevel++ ;
    }
    else
    {
	ivfile << hevUtils::indent(ivline+"\n", ivlevel) ;	
    }
}

////////////////////////////////////////////////////////////////////////
static bool doPolyN(void)
{
    if (coords->size()>0)
    {
	if (coords->size()%sides != 0) 
	{
	    osg::notify( osg::FATAL ) << OSGLOADERSTRING" file loader:: number of vertices not divisbible by number of sides" ;
	    return false ;
	}
	// bust up our collection of coords/normals/colors into seperate polygons
	osg::Vec3Array *copyCoords = new osg::Vec3Array(*coords) ;
	osg::Vec3Array *copyNorms = new osg::Vec3Array ;
	static bool doNorms ;
	if (norms->size() == coords->size())
	{
	    doNorms=true ;
	    copyNorms = new osg::Vec3Array(*norms) ;
	}
	osg::Vec4Array *copyColors = new osg::Vec4Array ;
	if (color==VERTEX)
	{
	    copyColors = new osg::Vec4Array(*colors) ;
	}
	primitive=POLY ;
	for (unsigned int i=0; i<copyCoords->size(); i+=sides)
	{
	    coords->clear() ;
	    if (doNorms) 
		norms->clear() ;
	    if (color==VERTEX)
	    {
		colors->clear() ;
	    }
	    for (unsigned int j=0; j<sides; j++)
	    {
		coords->push_back((*copyCoords)[i+j]) ;
		if (doNorms)
		    norms->push_back((*copyNorms)[i+j]) ;
		if (color==VERTEX)
		    colors->push_back((*copyColors)[i+j]) ;
	    }
	    doTriOrPolyOrLineOrPoint() ;
	}
    }
    return true ;
}

////////////////////////////////////////////////////////////////////////
static bool doTriOrPolyOrLineOrPoint(void)
{

    // set color if none specified
    if (color == DEFAULT)
	color = OVERALL ;

    //start new geometry
    osg::Geometry *geometry = new osg::Geometry ;

    if (gl3)
    {
	// use VBOs if possible
	geometry->setUseDisplayList(false) ;
	geometry->setUseVertexBufferObjects(true) ;
    }

    // turn polygons into tri-strips
    if (primitive == POLY)
    {
	polyToTristrip() ;
    }

    osg::Vec3Array *copyCoords = new osg::Vec3Array(*coords) ;
    geometry->setVertexArray(copyCoords) ;

    if (norms->size() >0) 
    {
	osg::Vec3Array *copyNorms = new osg::Vec3Array(*norms) ;
	geometry->setNormalArray(copyNorms) ;
	geometry->setNormalBinding(osg::Geometry::BIND_PER_VERTEX) ;
    }
    if (color == OVERALL)
    {
	osg::Vec4Array *singlecolor = new osg::Vec4Array;
	singlecolor->push_back(primColor) ;
	geometry->setColorArray(singlecolor) ;
	geometry->setColorBinding(osg::Geometry::BIND_OVERALL) ;
    }
    else if (color == VERTEX)
    {
	osg::Vec4Array *copyColors = new osg::Vec4Array(*colors) ;
	geometry->setColorArray(copyColors) ;
	geometry->setColorBinding(osg::Geometry::BIND_PER_VERTEX) ;
    }

    // vertex attributes
    {
	for (unsigned int i=1; i<16; i++)
	{
	    if (attributes[i].data && attributes[i].data->size()>0)
	    {
		//printf("attribute %d has %d values, size = %d\n",i,attributes[i].data->size(),attributes[i].size) ;
		if (attributes[i].data->size()%attributes[i].size != 0) return false ;
		if (attributes[i].size == 1)
		{
		    osg::FloatArray *v = new osg::FloatArray ;
		    for (unsigned int j=0; j<attributes[i].data->size(); j++)
		    {
			v->push_back((*attributes[i].data)[j]) ;
		    }
		    geometry->setVertexAttribArray(i, v);
		    if (attributes[i].data->size() > 1) geometry->setVertexAttribBinding(i, osg::Geometry::BIND_PER_VERTEX);
		    else geometry->setVertexAttribBinding(i, osg::Geometry::BIND_OVERALL);
		}
		else if (attributes[i].size == 2)
		{
		    osg::Vec2Array *v = new osg::Vec2Array ;
		    for (unsigned int j=0; j<attributes[i].data->size(); j+=2)
		    {
			v->push_back(osg::Vec2((*attributes[i].data)[j],(*attributes[i].data)[j+1])) ;
		    }
		    geometry->setVertexAttribArray(i, v);
		    if (attributes[i].data->size() > 2) geometry->setVertexAttribBinding(i, osg::Geometry::BIND_PER_VERTEX);
		    else geometry->setVertexAttribBinding(i, osg::Geometry::BIND_OVERALL);
		}
		else if (attributes[i].size == 3)
		{
		    osg::Vec3Array *v = new osg::Vec3Array ;
		    for (unsigned int j=0; j<attributes[i].data->size(); j+=3)
		    {
			v->push_back(osg::Vec3((*attributes[i].data)[j],(*attributes[i].data)[j+1],(*attributes[i].data)[j+2])) ;
		    }
		    geometry->setVertexAttribArray(i, v);
		    if (attributes[i].data->size() > 3) geometry->setVertexAttribBinding(i, osg::Geometry::BIND_PER_VERTEX);
		    else geometry->setVertexAttribBinding(i, osg::Geometry::BIND_OVERALL);
		}
		else if (attributes[i].size == 4)
		{
		    osg::Vec4Array *v = new osg::Vec4Array ;
		    for (unsigned int j=0; j<attributes[i].data->size(); j+=4)
		    {
			v->push_back(osg::Vec4((*attributes[i].data)[j],(*attributes[i].data)[j+1],(*attributes[i].data)[j+2],(*attributes[i].data)[j+3])) ;
		    }
		    geometry->setVertexAttribArray(i, v);
		    if (attributes[i].data->size() > 4) geometry->setVertexAttribBinding(i, osg::Geometry::BIND_PER_VERTEX);
		    else geometry->setVertexAttribBinding(i, osg::Geometry::BIND_OVERALL);
		}
	    }
	}
    }

    if (gl3)
    {
	unsigned int indices[coords->size()] ;
	for (unsigned int i=0; i<coords->size(); i++) indices[i] = i ;
	
	if (primitive == POLY || primitive == TRI)
	    geometry->addPrimitiveSet(new osg::DrawElementsUInt(GL_TRIANGLE_STRIP, coords->size(), indices)) ;
	else if(primitive == LINE)
	    geometry->addPrimitiveSet(new osg::DrawElementsUInt(GL_LINE_STRIP, coords->size(), indices)) ;
	else if(primitive == POINT)
	    geometry->addPrimitiveSet(new osg::DrawElementsUInt(GL_POINTS, coords->size(), indices)) ;
    }
    else
    {
	if (primitive == POLY || primitive == TRI)
	    geometry->addPrimitiveSet(new osg::DrawArrays(GL_TRIANGLE_STRIP, 0, coords->size())) ;
	else if(primitive == LINE)
	    geometry->addPrimitiveSet(new osg::DrawArrays(GL_LINE_STRIP, 0, coords->size())) ;
	else if(primitive == POINT)
	    geometry->addPrimitiveSet(new osg::DrawArrays(GL_POINTS, 0, coords->size())) ;
    }

    osg::Geode *geode ;
    if (transparency && (primitive == POLY || primitive == TRI)) geode = transparentGeometryPolysGeode ;
    else if (transparency && (primitive == POINT || primitive == LINE)) geode = transparentGeometryPointsLinesGeode ;
    else if (!transparency && (primitive == POLY || primitive == TRI)) geode = opaqueGeometryPolysGeode ;
    else if (!transparency && (primitive == POINT || primitive == LINE)) geode = opaqueGeometryPointsLinesGeode ;
    geode->addDrawable(geometry) ;

    return true ;
}

////////////////////////////////////////////////////////////////////////
// rearrange points so a polygon becomes a tri-strip
void polyToTristrip()
{
    // make a copy of the vertices
    osg::Vec3Array *copyCoords = new osg::Vec3Array(*coords) ;
    osg::Vec3Array *copyNorms = new osg::Vec3Array(*norms) ;
    osg::Vec4Array *copyColors = new osg::Vec4Array(*colors) ;
    attribute copyAttributes[16] ;
    for (unsigned int j=1; j<16; j++)
    {
	if (attributes[j].size != 0)
	{
	    //printf("copying attribute %d\n",j) ;
	    //printf("attribute %d size = %d\n",j,attributes[j].size) ;
	    //printf("attribute %d data size = %d\n",j,attributes[j].data->size()) ;
	    copyAttributes[j].data = new std::vector<float> ;
	    *(copyAttributes[j].data) = *(attributes[j].data) ;
	}
    }

    unsigned int n = coords->size() ;
    for (unsigned int i=1; i<n; i++)
    {
	if (i%2)
	{
	    //printf("odd  coord %d gets value of coord %d\n",i, (i+1)/2) ;
	    (*coords)[i] = (*copyCoords)[(i+1)/2] ;
	    if (norms->size()>0) (*norms)[i] = (*copyNorms)[(i+1)/2] ;
	    if (colors->size()>0) (*colors)[i] = (*copyColors)[(i+1)/2] ;
	    for (unsigned int j=1; j<16; j++)
	    {
		if (attributes[j].size != 0)
		{
		    for (unsigned int k=0; k<attributes[j].size; k++)
		    {
			unsigned int size = attributes[j].size ;
			(*attributes[j].data)[i*size + k] = 
			    (*copyAttributes[j].data)[((i+1)*size)/2 + k] ;
		    }
		}
	    }
	}
	else
	{
	    //printf("even coord %d gets value of coord %d\n",i, n-(i/2)) ;
	    (*coords)[i] = (*copyCoords)[n-(i/2)] ;
	    if (norms->size()>0) (*norms)[i] = (*copyNorms)[n-(i/2)] ;
	    if (colors->size()>0) (*colors)[i] = (*copyColors)[n-(i/2)] ;
	    for (unsigned int j=1; j<16; j++)
	    {
		if (attributes[j].data != 0) 
		{
		    for (unsigned int k=0; k<attributes[j].size; k++)
		    {
			unsigned int size = attributes[j].size ;
			(*attributes[j].data)[i*size + k] = 
			    (*copyAttributes[j].data)[(n*size)-((i*size)/2)+k] ;
		    }
		}
	    }
	}
    }

    for (unsigned int j=1; j<16; j++)
    {
	if (attributes[j].size != 0)
	{
	    delete copyAttributes[j].data ;
	}
    }
}

////////////////////////////////////////////////////////////////////////
bool parseAttribute(std::vector<std::string> vec)
{
    // process previous primitive, if any
    if (!processPrimitive()) return false ;

    if (!hevUtils::isSubstring("ATTRIBUTE",vec[0],3)) return false ;

    if (vec.size() != 3) return false ;

    int index ;
    if (!hevUtils::putInt(vec[1], &index)) return false ;

    int size ;
    if (!hevUtils::putInt(vec[2], &size)) return false ;

    if (index<1 || index>15 || size <1 || size>4) return false ;

    if (attributes[index].data != NULL) return false ;  // already have an attribute for this index 

    attributes[index].size = size ;
    attributes[index].data = new std::vector<float> ;

    return true ;
}

////////////////////////////////////////////////////////////////////////
bool parseProgram(std::vector<std::string> vec)
{
    // process previous primitive, if any
    if (!processPrimitive()) return false ;

    if (!hevUtils::isSubstring("PROGRAM",vec[0],3)) return false ;

    if (vec.size() < 3) return false ;

    program p ;

    if (hevUtils::isSubstring("VERTEX",vec[1],3)) p.type = osg::Shader::VERTEX ;
    else if (hevUtils::isSubstring("GEOMETRY",vec[1],3)) p.type = osg::Shader::GEOMETRY ;
    else if (hevUtils::isSubstring("FRAGMENT",vec[1],3)) p.type = osg::Shader::FRAGMENT ;
    else return false ;

    // look for geomSpec
    std::string::size_type idx = vec[1].find(":") ;
    if (p.type == osg::Shader::GEOMETRY && idx != std::string::npos)
    {
	std::string geomSpec = vec[1].substr(idx+1) ;
	if (geomSpec.size()<3) return false ;

	if (geomSpec[0] == 't' || geomSpec[0] == 'T') p.inputType = GL_TRIANGLES ;
	else if (geomSpec[0] == 'p' || geomSpec[0] == 'P') p.inputType = GL_POINTS ;
	else if (geomSpec[0] == 'l' || geomSpec[0] == 'L') p.inputType = GL_LINES ;
	else return false ;

	if (geomSpec[1] == 't' || geomSpec[1] == 'T') p.outputType = GL_TRIANGLE_STRIP ;
	else if (geomSpec[1] == 'p' || geomSpec[1] == 'P') p.outputType = GL_POINTS ;
	else if (geomSpec[1] == 'l' || geomSpec[1] == 'L') p.outputType = GL_LINE_STRIP ;
	else return false ;
	
	if (!hevUtils::putInt(geomSpec.substr(2), &(p.maxVertices))) return false ;
    }
    else
    {
	p.inputType = GL_TRIANGLES ;
	p.outputType = GL_TRIANGLE_STRIP ;
	p.maxVertices = 3 ;
    }

    p.name = vec[2] ;

    unsigned int i = 3 ;
    while (i<vec.size())
    {
	if (i+1>=vec.size()) return false ;
	int index ;
	if (!hevUtils::putInt(vec[i], &index)) return false ;
	if (index<1 || index>15) return false ;
	if (p.attributes[index] != "") return false ; 
	p.attributes[index] = vec[i+1] ; 
	i+=2 ;
    }

    programs.push_back(p) ;

    return true ;
}

////////////////////////////////////////////////////////////////////////
void writePrograms(osg::Node *n)
{
    if (programs.size() == 0) return ;

    osg::StateSet *ss = n->getOrCreateStateSet() ;
    osg::Program *p ;
    for (unsigned int i=0; i<programs.size(); i++)
    {
	//fprintf(stderr,"program %d: %s\n",i,programs[i].name.c_str()) ;
	if (i==0)
	{
	    p = new osg::Program ;
	    ss->setAttribute(p) ;
	}
	else
	{
	    p = dynamic_cast<osg::Program*>(ss->getAttribute(osg::StateAttribute::PROGRAM)) ;
	}
	osg::Shader *s = new osg::Shader(programs[i].type) ;

	// geomSpec
	if (programs[i].type == osg::Shader::GEOMETRY)
	{
	    p->setParameter( GL_GEOMETRY_VERTICES_OUT_EXT, programs[i].maxVertices );
	    p->setParameter( GL_GEOMETRY_INPUT_TYPE_EXT, programs[i].inputType);
	    p->setParameter( GL_GEOMETRY_OUTPUT_TYPE_EXT, programs[i].outputType);
	}

	struct stat buf ;
	std::string fullpath ;
	if (stat(programs[i].name.c_str(),&buf) == 0) fullpath = programs[i].name ;
	else
	{
	    // need to get path so can load from data dirs
	    // there's got to be an easier way
	    for (unsigned int j=0; j<shaderpath.size(); j++)
	    {
		fullpath = shaderpath[j] + std::string("/") + programs[i].name ;
		if (stat(fullpath.c_str(),&buf) == 0)
		{
		    break ;
		}
	    }
	}

	//printf("fullpath = %s\n",fullpath.c_str()) ;
	
	s->loadShaderSourceFromFile(fullpath) ;
	p->addShader(s) ;
	for (unsigned int j=1; j<16; j++)
	{
	    if (programs[i].attributes[j] != "") p->addBindAttribLocation(programs[i].attributes[j], j) ;
	}
    }
}

////////////////////////////////////////////////////////////////////////
void setTransparency(osg::StateSet *ss)
{
	ss->setRenderingHint(osg::StateSet::TRANSPARENT_BIN);
	ss->setMode(GL_BLEND, osg::StateAttribute::ON | osg::StateAttribute::PROTECTED);
}
////////////////////////////////////////////////////////////////////////
void printNode(unsigned int level, osg::Node *node)
{
    osg::Group *group = node->asGroup() ;
    osg::Geode *geode = node->asGeode() ;

    if (group && geode) 
    {
	fprintf(stderr,"a node named \"%s\" is both a group and a geode?\n",node->getName().c_str()) ;
	exit(1) ;
    }

    for(unsigned int i=0; i<level; i++) fprintf(stderr,"  ") ;

    if (!group && !geode) 
    {
	fprintf(stderr,"a node named \"%s\" is neither a group and a geode?\n",node->getName().c_str()) ;
    }

    if (group)
    {
	fprintf(stderr,"group node \"%s\" has %d children\n",group->getName().c_str(),group->getNumChildren()) ;
	for (unsigned int i=0; i<group->getNumChildren(); i++)
	{
	    printNode(level+1,group->getChild(i)) ;
	}
    }

    if (geode)
    {
	fprintf(stderr,"geode \"%s\" has %d drawables\n",geode->getName().c_str(),geode->getNumDrawables()) ;
    }
}
