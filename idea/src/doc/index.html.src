<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><!--This file was converted to xhtml by OpenOffice.org - see http://xml.openoffice.org/odf2xhtml for more info.--><head profile="http://dublincore.org/documents/dcmi-terms/"><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/><title xmlns:ns_1="http://www.w3.org/XML/1998/namespace" ns_1:lang="en-US">IDEA overview</title><meta xmlns:ns_1="http://www.w3.org/XML/1998/namespace" name="DCTERMS.title" content="IDEA overview" ns_1:lang="en-US"/><meta name="DCTERMS.language" content="en-US" scheme="DCTERMS.RFC4646"/><meta name="DCTERMS.source" content="http://xml.openoffice.org/odf2xhtml"/><meta name="DCTERMS.issued" content="2011-06-07T10:12:41" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.modified" content="2013-05-29T14:23:48" scheme="DCTERMS.W3CDTF"/><meta xmlns:ns_1="http://www.w3.org/XML/1998/namespace" name="DCTERMS.provenance" content="" ns_1:lang="en-US"/><meta xmlns:ns_1="http://www.w3.org/XML/1998/namespace" name="DCTERMS.subject" content="," ns_1:lang="en-US"/><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" hreflang="en"/><link rel="schema.DCTERMS" href="http://purl.org/dc/terms/" hreflang="en"/><link rel="schema.DCTYPE" href="http://purl.org/dc/dcmitype/" hreflang="en"/><link rel="schema.DCAM" href="http://purl.org/dc/dcam/" hreflang="en"/><style type="text/css">
	@page {  }
	table { border-collapse:collapse; border-spacing:0; empty-cells:show }
	td, th { vertical-align:top; font-size:12pt;}
	h1, h2, h3, h4, h5, h6 { clear:both }
	ol, ul { margin:0; padding:0;}
	li { list-style: none; margin:0; padding:0;}
	<!-- "li span.odfLiEnd" - IE 7 issue-->
	li span. { clear: both; line-height:0; width:0; height:0; margin:0; padding:0; }
	span.footnodeNumber { padding-right:1em; }
	span.annotation_style_by_filter { font-size:95%; font-family:Arial; background-color:#fff000;  margin:0; border:0; padding:0;  }
	* { margin:0;}
	.P1 { font-size:12pt; font-family:Arial; writing-mode:page; margin-top:0in; margin-bottom:0.2402in; }
	.P2 { font-size:12pt; font-family:Arial; writing-mode:page; margin-top:0in; margin-bottom:0.2402in; }
	.P3 { font-size:12pt; font-family:Arial; writing-mode:page; margin-top:0in; margin-bottom:0.2402in; text-align:left ! important; }
	.P4 { font-size:12pt; font-family:Tahoma; writing-mode:page; margin-top:0in; margin-bottom:0.2402in; }
	.P5 { font-size:12pt; font-family:Arial; writing-mode:page; margin-left:0.4925in; margin-right:0in; margin-top:0in; margin-bottom:0.2402in; text-indent:0in; }
	.P6 { border-bottom-width:0.0399cm; border-bottom-style:double; border-bottom-color:#808080; border-left-style:none; border-right-style:none; border-top-style:none; font-size:12pt; margin-bottom:0.1965in; margin-top:0in; padding:0in; font-family:Arial; writing-mode:page; }
	.P8 { font-size:12pt; font-family:Arial; writing-mode:page; margin-top:0in; margin-bottom:0.2402in; }
	.T1 { font-family:Arial; font-size:12pt; }
	.T2 { font-style:italic; }
	<!-- ODF styles with no properties representable as CSS -->
	.Numbering_20_Symbols { }
	</style></head><body dir="ltr" style="max-width:8.5in;margin-top:0.7874in; margin-bottom:0.7874in; margin-left:0.7874in; margin-right:0.7874in; writing-mode:lr-tb; "><p class="P2">IDEA overview:</p><p class="P2"><span class="T2">This page provides a brief overview of IDEA software. We also have a more complete set of </span><a href="./"><span class="T2">HEV and IDEA man pages</span></a><span class="T2"> in PDF format.</span></p><p class="P2">IDEA (IRIS Development Environment for Applications) is a collection of programs and utilities which facilitate the creation of portable visualization application.</p><p class="P4"><span class="T1">An IDEA application is generally a collection of one or more asynchronous processes which communicate with each other and the </span><a href="./../../../iris/iris-v1.x/installed/doc/html/index.html"><span class="T1">IRIS</span></a><span class="T1"> graphics engine via Unix </span><a href="http://en.wikipedia.org/wiki/Named_pipe"><span class="T1">named pipes</span></a><span class="T1">, also known as fifos, and/or </span><a href="http://www.sv.vt.edu/future/cave/pub/jaws_diverse/diverse_jaws.pdf"><span class="T1">DIVERSE</span></a><span class="T1"> shared memory files.</span></p><p class="P4"><span class="T1">Fifos are best used for short text strings that are exchanged between processes. The </span><a href="./../../../iris/iris-v1.x/installed/doc/html/classiris_1_1FifoReader.html"><span class="T1">iris::FifoReader</span></a><span class="T1"> class and </span><a href="./../../../iris/iris-v1.x/installed/doc/pdf/iris-readFifo.pdf"><span class="T1">iris-readFifo</span></a><span class="T1"> command facilitate both C++ and command line access to fifos.</span></p><p class="P4"><span class="T1">Graphics is implemented via the </span><a href="./../../../iris/iris-v1.x/installed/doc/html/classiris_1_1SceneGraph.html"><span class="T1">iris::SceneGraph</span></a><span class="T1"> class, which is in turn based on the </span><a href="http://www.openscenegraph.org/projects/osg"><span class="T1">OpenSceneGraph</span></a><span class="T1"> (OSG) C++ API.  The </span><a href="./../../../iris/iris-v1.x/installed/doc/pdf/iris-viewer.pdf"><span class="T1">iris-viewer </span></a><span class="T1">program is the IRIS general purpose graphics display program. It can load model files and display them in a variety of settings, from generic mono desktops to multi-display head-tracked immersive stereo displays such as the NIST RAVE and PowerWall.</span></p><p class="P4"><span class="T1">IRIS implements navigational tools and other utilities using Unix </span><a href="http://techpubs.sgi.com/library/dynaweb_docs/0530/SGI_Developer/books/Cplr_PTG/sgi_html/ch03.html"><span class="T1">Dynamic Shared Objects</span></a><span class="T1"> (DSOs). In general one should not use or write a DSO if other options are available, as DSOs execute in the graphics loop and therefore can adversely impact the graphics frame rate. </span><a href="./../../../../../usr/local/HEV/iris/iris-v1.x/installed/doc/html/dsos.html"><span class="T1">See this note for more information about IRIS DSOs</span></a><span class="T1">.</span></p><p class="P4"><span class="T1">The IRIS SceneGraph class creates a simple </span><a href="./../../../iris/iris-v1.x/installed/doc/pdf/scenegraph.pdf"><span class="T1">scenegraph</span></a><span class="T1"> which simplifies the creation of graphical modeling transformations. An application will load each model file under the node most appropriate to its intended use.</span></p><p class="P4"><span class="T1">Every graphics frame the iris-viewer program, via the SceneGraph class, reads control commands from a fifo named $IRIS_CONTROL_FIFO. </span><a href="./../../../../../usr/local/HEV/iris/iris-v1.x/installed/doc/html/control.html"><span class="T1">A list of all control commands is in the IRIS documentation.</span></a><span class="T1">  These commands can be used to manipulate and query the scenegraph and graphics state as well as manage the execution of asynchronous processes.</span></p><p class="P2">One or more IRIS control commands can be written to a file with the suffix "iris" and then loaded by iris-viewer just like any other model file.</p><p class="P4"><span class="T1">The IDEA program </span><a href="./irisfly.1.pdf"><span class="T1">irisfly</span></a><span class="T1"> is a front-end to the iris-viewer command which automatically configures it for our specific hardware environments. It specifies the DSOs and iris files for iris-viewer to load. The DSOs create the displays and navigations suitable for the hardware environment, and the iris files create background process which create a GUI menu and maintain shared memory files that contain graphical state information.</span></p><p class="P4"><span class="T1">Shared memory files are best for transmitting blocks of binary data of a fixed size. Shared </span><span class="T1">memory files can be read as either queued or polled data. Queued reads can be used to access every  change in the data, whereas polled reads just give the current state of the data. The needs of your application will determine which is most appropriate. There exists both a </span><a href="./../../../../../usr/local/HEV/external/dtk/installed/doc/dtk/html/classes/classdtkSharedMem.html"><span class="T1">shared memory file</span></a><span class="T1"> C++ API as well as command line interfaces to shared memory files: See </span><a href="./hev-readButtons.1.pdf"><span class="T1">hev-readButtons</span></a><span class="T1">, </span><a href="./hev-readDoubles.1.pdf"><span class="T1">hev-readDoubles</span></a><span class="T1">, </span><a href="./hev-readFloats.1.pdf"><span class="T1">hev-readFloats</span></a><span class="T1">, </span><a href="./hev-readInts.1.pdf"><span class="T1">hev-readInts</span></a><span class="T1">, </span><a href="./hev-readStrings.1.pdf"><span class="T1">hev-readStrings</span></a><span class="T1">, </span><a href="./hev-writeButtons.1.pdf"><span class="T1">hev-writeButtons</span></a><span class="T1">, </span><a href="./hev-writeDoubles.1.pdf"><span class="T1">hev-writeDoubles</span></a><span class="T1">, </span><a href="./hev-writeFloats.1.pdf"><span class="T1">hev-writeFloats</span></a><span class="T1">, </span><a href="./hev-writeInts.1.pdf"><span class="T1">hev-writeInts</span></a><span class="T1">, </span><a href="./hev-writeStrings.1.pdf"><span class="T1">hev-writeStrings</span></a></p><p class="P1"><span class="T1">In the immersive environment a hardware tracker maintains the position of the head and wand devices, and the state of the joystick and buttons attached to the wand. These data are automatically written to shared memory files using a background process. In desktop environments these same shared memory files can be written to by graphical user interfaces (GUIs) which simulate the tracked devices, such as </span><a href="./hev-desktopWand.1.pdf"><span class="T1">hev-desktopWand</span></a><span class="T1">, </span><a href="./hev-relativeMove.1.pdf"><span class="T1">hev-relativeMove</span></a><span class="T1">, and </span><a href="./hev-xyzPositioner.1.pdf"><span class="T1">hev-xyzPositioner</span></a></p><p class="P2">The shared memory files created by irisfly are:</p><p class="P1"><span class="T1">headMatrix: contains 16 doubles, which are the data contained in an </span><a href="http://www.openscenegraph.org/documentation/OpenSceneGraphReferenceDocs/a00403.html"><span class="T1">osg::Matrix</span></a><span class="T1">, representing the position of the tracked or virtual head in scene node coordinates.</span></p><p class="P2">wandMatrix: contains a matrix which represents the position of the tracked or virtual wand, in scene node coordinates.</p><p class="P2">idea/buttons/left and idea/buttons/right: the state of the left and right buttons, either the physical buttons connected to the wand, or virtual buttons generated by software.</p><p class="P2">idea/selector: a text string that is used to specify which application is currently "active". The selector string is a convention which allows multiple processes to share a single device. For example, an application needs to control which sub-process is the one that should be responding to button press events. Every application chooses a unique text string for the selector shared memory file and before responding to a button press, compares the contents of the selector shared memory file with its unique text string. If they match, the application processes the button press event; if they don't it ignores it. The selector's string can be set by a manager process that understands the data flow of the application and sets the selector's string as appropriate, or perhaps more commonly, the selector's text string is set by the user choosing tasks from a menu.</p><p class="P2">idea/worldToScene: contains the matrix representation of the transformation from the world node to the scene node.</p><p class="P2">idea/wandOffsetDistance: is a single floating point number that represents a distance in scene node coordinates.  It is used by idea/offsetWand, below.</p><p class="P2">idea/offsetWand: contains a matrix which represents the position "idea/wandOffsetDistance" units in front of the wand, in the wand's local coordinate system. This is used to position probe devices in the scenegraph.</p><p class="P2">idea/worldOffsetWand:  contains a matrix which represents idea/offsetWand in world coordinates.</p><p class="P2">idea/worldWand: contains a matrix which represents wandMatrix in world coordinates.</p><p class="P2">The general approach when writing an IDEA application is to create one or more programs that communicate with iris-viewer via iris control commands and shared memory files. The easiest way to write control commands is to have the program just print the commands to standard output (doing a fflush() after every batch of commands to be sure they are not buffered by the OS). For example, if your application is named myApp, it would be run with the command:</p><p class="P5">myApp &gt; $IRIS_CONTROL_FIFO</p><p class="P2">The best way to run this command is using the EXEC control command in a iris file and loading the iris file on the irisfly command line. If the file myApp.iris contains:</p><p class="P5">EXEC myApp &gt; $IRIS_CONTROL_FIFO</p><p class="P2">It can be loaded with the command:</p><p class="P5">irisfly myApp.iris</p><p class="P2">This method ensures that myApp will be terminated when irisfly exits.</p><p class="P2">If your program has a GUI you will probably want this GUI to appear after the graphics windows are created so that the GUI won't be covered by the windows. Do this with the command:</p><p class="P5">AFTER REALIZE EXEC myApp &gt; $IRIS_CONTROL_FIFO</p><p class="P1"><span class="T1">Our GUI programs are written in </span><a href="http://www.fltk.org/doc-1.3/index.html"><span class="T1">FLTK</span></a><span class="T1">, a simple but powerful API which also has its own GUI based GUI builder program named </span><a href="http://www.fltk.org/doc-1.3/fluid.html"><span class="T1">fluid</span></a><span class="T1">. </span></p><p class="P2">An example FLTK program that can be copied and modified is in the directory:</p><p class="P5">$HEVROOT/idea/examples/showCursorPositionInImage</p><p class="P1"><span class="T1">If you just need a GUI to turn objects on and off, see the </span><a href="./hev-moo.1.pdf"><span class="T1">hev-moo</span></a><span class="T1"> command. If you have a "flip book" animation, such as the output of a simulation that creates one model file per time step, take a look at </span><a href="./hev-animator.1.pdf"><span class="T1">hev-animator</span></a><span class="T1"> and </span><a href="./hev-animatorIRIS.1.pdf"><span class="T1">hev-animatorIRIS</span></a><span class="T1">.</span></p><p class="P1"><span class="T1">If you need make pictures or movies of your IRIS sessions use the frameGrabber DSO. The </span><a href="./../../../../../usr/local/HEV/doc/idea/overview/hev-frameGrabberControl.1.pdf"><span class="T1">hev-frameGrabberControl</span></a><span class="T1"> program provides a GUI front-end to the DSO.</span></p><p class="P2">The easiest way to use it is just load the file grab.iris; for example::</p><p class="P5">irisfly –ex tape.osg grab.iris</p><p class="P1"><span class="T1">A simple but fairly handy menu button package is called </span><a href="./hev-masterControlPanel.1.pdf"><span class="T1">hev-masterControlPanel</span></a><span class="T1"> (MCP). A basic MCP control panel is created by irisfly, but this menu can be modified by creating files of menu commands called mcp files, or augmented by using the </span><a href="./irisfly-addToMCP.1.pdf"><span class="T1">irisfly-addToMCP</span></a><span class="T1"> command.</span></p><p class="P2">Just as our software is built in layers, there are user commands for each layer of software. All have man pages, and most have examples in their source directory. An easy way to get a list of the commands at each layer is to type the prefix common to all of the commands in a particular layer and press the &lt;TAB&gt; key twice.</p><p class="P2">All IRIS commands begin with "iris-", so if you type </p><p class="P5">iris-&lt;TAB&gt;&lt;TAB&gt; </p><p class="P2">you will get a list of all IRIS commands. Similarly, all IDEA commands begin with, for historical purposes, "hev-", and all irisfly commands (except the irisfly command itself) begin with "irisfly-".</p><p class="P2">All IRIS software is under the directory /usr/local/HEV. To use IRIS you need to set up its  environment by typing the command:</p><p class="P5">source /usr/local/HEV/profile iris</p><p class="P2">Among many other things it will set the environment variable $HEVROOT to /usr/local/HEV.  In your programs, please use $HEVROOT instead of /usr/local/HEV.</p><p class="P1"><span class="T1">The directories under $HEVROOT are described in the file </span><a href="./../../../../../usr/local/HEV/doc/HEV_IRIS_Tree.txt"><span class="T1">$HEVROOT/doc/HEV_IRIS_Tree.txt</span></a><span class="T1">.</span></p><p class="P2">Most commands have test and example code in their source directories. For the IDEA command hev-madeUpExample, they would be in $HEVROOT/idea/src/ hev-madeUpExample.</p><p class="P1"><span class="T1">To build your application you use the </span><a href="http://www.gnu.org/software/make/manual/make.html"><span class="T1">make</span></a><span class="T1"> command. If you are building a general purpose tool, copy the file $HEVROOT/idea/GNUmakefile.template into your development directory, but give the new file the name GNUmakefile. If you are writing a specific demo application, use the file $HEVROOT/demos/GNUmakefile.template. The GNUmakefile has variables that can be set to describe what sort of software you will be building, how it should be built and where it ultimately should be installed.</span></p><p class="P2">Please note that you develop your software outside of the $HEVROOT directory. When it is ready to be installed someone on the staff will assist you with this.</p><p class="P2">If you application needs temporary data files you need to:</p><ol><li><p class="P8" style="margin-left:0cm;"><span style="display:block;float:left;min-width:0cm">1)</span>put them in a directory that anyone can write to, such as /tmp<span class="odfLiEnd"/> </p></li><li><p class="P8" style="margin-left:0cm;"><span style="display:block;float:left;min-width:0cm">2)</span>give them a name that is unique for every user. This can be accomplished by using the $USER environment variable in the file's name<span class="odfLiEnd"/> </p></li><li><p class="P8" style="margin-left:0cm;"><span style="display:block;float:left;min-width:0cm">3)</span>the files need to be deleted when the application exits<span class="odfLiEnd"/> </p></li></ol><p class="P3">Your application also needs to kill off all processes it creates. Processes created by the EXEC control command will be killed when IRIS exits, but sub-processes the process creates will not. If running a shell script, see the example in $HEVROOT/iris/iris-v1.x/examples/shell.</p><p class="P1"><span class="T1">If your application will be creating model files your graphics performance can be greatly increased by optimizing the model files. The </span><a href="./../../../iris/iris-v1.x/installed/doc/pdf/iris-convert.pdf"><span class="T1">iris-convert </span></a><span class="T1">command can be used to both optimize the data within a model file and to write it to a format that can be loaded more quickly. Always write scripts to regenerate your final model files from the original data.</span></p><p class="P1"><span class="T1">You also might need to change your model's position, orientation or scale. The </span><a href="./../../../iris/iris-v1.x/installed/doc/pdf/iris-DCS.pdf"><span class="T1">iris-DCS</span></a><span class="T1"> command can be used to create an iris file that you can then load and convert with iris-convert to allow your model files to be loaded quickly, and with the desired geometric transformation.</span></p><p class="P6"> </p><p class="P2"> </p><p class="P2">$HEVROOT/docs/idea/overview/index.odt, kelso@nist.gov, 6/8/11</p><p class="P2">$HEVROOT/docs/idea/overview/index.odt, kelso@nist.gov, 7/25/11</p><p class="P2">$HEVROOT/docs/idea/overview/index.odt, JGH, 5/29/13</p><p class="P2"> </p></body></html>
