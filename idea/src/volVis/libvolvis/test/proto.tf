

OK, so the idea here is that in GLSL, the top level transfer
function will take no arguments and will return an rgba vec4.
So:
        vec4 tf ()
will be the signature.

So the transfer function implicitly returns RGBA at a 
"current position" in a volume.

All inputs that the TF needs to derive the RGBA will be obtained by 
calls like this:

   vec3 currPos = tfPos ();     // get the current position 
   vec3 prevPos = tfPosPrev (); // get previously accessed position
                                // this is assumed to be the prev
                                // position along a ray traversal
   float val = tfScalar ();     // value of scalar field at current pos
   float gr = tfGrad ();        // gradient vector of scalar field

It is the responsibility of the calling code to provide these
functions.  

The TF class (in application code, not GLSL code) must be able to provide a 
list of the fuctions required.

Under some circumstances, the transfer function may want to output data other
than a color.  (I'll refer to these as auxiliary outputs.) This will be done by 
calls to functions like this:

        tfSetVarName (value)

but we'll cross that bridge when we come to it.



BUT: How do we chain execution????
How about this:  basic tf class has methods 
        addReqNameSuffix(nm) - adds a suffix which is "" by default
        setReqNameSuffix (suffix) - sets the suffix
The add... function is always used when generating GLSL

So when we chain functions, and the output of one goes to the input of the
next, we glue them together by taking the output of one, stuffing it into
a global variable, define a function with a modified name to provide that
global to the next function.  Make the next TF use a modified name for its
function by which it obtains the input data.

Or perhaps this is done on a function by function basis.  You might want to
change the input provided by tfPos, but not that provided by tfScalar?





So here are revised formats:



FUNC RGBALUT1D CO2.D 
    # note that this implicitly requires tfScalar
    # and if lighting is done, it also requires tfPos, tfPosPrev, tfGrad
    # could encode this like this:
    REQUIRES float tfScalar ()
    REQUIRES vec3  tfGrad ()
    REQUIRES vec3  tfPos ()
    REQUIRES vec3  tfPosPrev ()
    # but note that all of this is implicit in the other specifications of 
    # this function.
    # Maybe when these files are generated by software, these could
    # included as comments.

    VAL_TRANSFORM LOG10


    COLOR_INTERP RGB # or: HSV, CIELAB, DIVERGING, NEAREST
    TABLE_COMBINED YES
    TABLE_LEN 256
    TABLE_TYPE UCHAR  # or FLOAT
 
    RGBLUT
        1.000000e-20        0.0     1.0     0.0
        1.208796e-20        0.4     0.1     0.7
        3.981072e-15        0.2     0.2     0.6
        6.843750e-07        0.1     0.6     0.6
        5.976826e-02        0.1     0.6     0.2
        1.000000e+01        0.1     0.7     0.1
    END_RGBLUT


    ALPHALUT
        1.000000e-20        0.0
        1.208796e-20        0.0035
        3.981072e-15        0.0050
        6.843750e-07        0.025
        5.976826e-02        0.065
        1.000000e+01        0.3
   END_ALPHALUT


END_FUNC

FUNC SOME_FUNC_TYPE  anotherF  I[6] O[3]
....
END_FUNC

FUNC EXEC myExec inp[4] outp[2]

OK here's where the explicit REQUIRES might be useful.

  # Only three types of lines can be present in an EXEC function: 
  #    declaration of a new variable
  #    invoking a function
  #    direct assignment
  #
  # For parsing, note that the declaration starts with _NEW and
  # the other two must have a = and it's probably useful to
  # break the line into two strings: the part to the left and the part
  # to the right of the = .
  # for the RHS, check the first token.  If it starts with (, it's
  # a direct assignment, if not, it's # an invocation. 
  # If it's an invocation, separate RHS into part before the first (
  # and the rest.
  # I think that all commas can be changed to blanks before parsing.
  # And I think that we have to recognize parens.

  # Note: no line continuation, no semi-colon

  # Create a local variable
  _NEW tmpVar[3]

  # Call CO2.D with input of inp[0] and assign output to four variables
  (tmpVar[0], outp[1], outp[0], tmpVar[2]) = CO2.D (inp[0])

  # Call anotherF.
  # In next call, note that we use "outp" to mean "outp[0], outp[1]"
  #   and "inp" to mean "inp[0], inp[2], inp[3], inp[4]"
  (tmpVar[1], outp) = anotherF (inp, tmpVar[0], tmpVar[2])

  # assign a vector of values to outp
  outp = (inp[3], tmpVar[0])
  # this is equivalent to:
  #    outp[0] = inp[3]
  #    outp[1] = tmpVar[0]
  

END_FUNC 


# Maybe something like this for indicating preprocessing:

FUNC EXEC myfunc I[1] O[1]
  PREPROCESS
  O = GRADIENT_MAGNITUDE ( I )
  # how do we hook this up with actual file names?
END_FUNC
